// --------------------------------------------------------------------------------------------------------------------
// <copyright file="MathHelper.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Math source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Math
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    using Conditions;

    /// <summary>
    /// Supports various mathematical and numerical methods.
    /// </summary>
#if !RecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Math", "See package version number")]
#endif
    internal static class MathHelper
    {
        /// <summary>
        /// Determines if two values are almost equal (given some level of tolerance).
        /// </summary>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The the second value.</param>
        /// <param name="tolerance">
        /// The tolerance for differences between the specified values.  If the
        /// absolute value of the difference between the two values is less than or equal to
        /// this tolerance, then the two values are considered to be almost equal.
        /// </param>
        /// <returns>
        /// true if the two values are almost equal, false if not.
        /// </returns>
        /// <exception cref="ArgumentException">value1 or value2 is double.NaN</exception>
        /// <exception cref="ArgumentOutOfRangeException">tolerance is not &gt;= 0</exception>
        public static bool IsAlmostEqualTo(this double value1, double value2, double tolerance = 1e-8)
        {
            double.IsNaN(value1).Requires().IsFalse("value1 is NaN");
            double.IsNaN(value2).Requires().IsFalse("value2 is NaN");
            tolerance.Requires(nameof(tolerance)).IsGreaterOrEqual(0);

            var diff = Math.Abs(value1 - value2);
            var almostEqual = diff <= tolerance;
            return almostEqual;
        }

        /// <summary>
        /// Determines if two values are almost equal (given some level of tolerance).
        /// </summary>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The the second value.</param>
        /// <param name="tolerance">
        /// The tolerance for differences between the specified values.  If the
        /// absolute value of the difference between the two values is less than or equal to
        /// this tolerance, then the two values are considered to be almost equal.
        /// </param>
        /// <returns>
        /// true if the two values are almost equal, false if not.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">tolerance is not &gt;= 0</exception>
        public static bool IsAlmostEqualTo(this decimal value1, decimal value2, decimal tolerance = 1e-8m)
        {
            tolerance.Requires(nameof(tolerance)).IsGreaterOrEqual(0);

            var diff = Math.Abs(value1 - value2);
            var almostEqual = diff <= tolerance;
            return almostEqual;
        }

        /// <summary>
        /// Determines if one value is greater than or almost equal (given some level of tolerance) to a second value.
        /// </summary>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The the second value.</param>
        /// <param name="tolerance">
        /// The tolerance for differences between the specified values.  If the
        /// absolute value of the difference between the two values is less than or equal to
        /// this tolerance, then the two values are considered to be almost equal.
        /// </param>
        /// <returns>
        /// true if the first value is greater than or almost equal to the second value, false if not.
        /// </returns>
        /// <exception cref="ArgumentException">value1 or value2 is double.NaN</exception>
        /// <exception cref="ArgumentOutOfRangeException">tolerance is not &gt;= 0</exception>
        public static bool IsGreaterThanOrAlmostEqualTo(this double value1, double value2, double tolerance = 1e-8)
        {
            double.IsNaN(value1).Requires().IsFalse("value1 is NaN");
            double.IsNaN(value2).Requires().IsFalse("value2 is NaN");
            tolerance.Requires(nameof(tolerance)).IsGreaterOrEqual(0);

            var result = (value1 > value2) || value1.IsAlmostEqualTo(value2, tolerance);
            return result;
        }

        /// <summary>
        /// Determines if one value is greater than or almost equal to a second value (given some level of tolerance).
        /// </summary>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The the second value.</param>
        /// <param name="tolerance">
        /// The tolerance for differences between the specified values.  If the
        /// absolute value of the difference between the two values is less than or equal to
        /// this tolerance, then the two values are considered to be almost equal.
        /// </param>
        /// <returns>
        /// true if the first value is greater than or almost equal to the second value, false if not.
        /// </returns>
        /// <exception cref="ArgumentException">value1 or value2 is double.NaN</exception>
        /// <exception cref="ArgumentOutOfRangeException">tolerance is not &gt;= 0</exception>
        public static bool IsGreaterThanOrAlmostEqualTo(this decimal value1, decimal value2, decimal tolerance = 1e-8m)
        {
            tolerance.Requires(nameof(tolerance)).IsGreaterOrEqual(0);

            var result = (value1 > value2) || value1.IsAlmostEqualTo(value2, tolerance);
            return result;
        }

        /// <summary>
        /// Determines if one value is less than or almost equal (given some level of tolerance) to a second value.
        /// </summary>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The the second value.</param>
        /// <param name="tolerance">
        /// The tolerance for differences between the specified values.  If the
        /// absolute value of the difference between the two values is less than or equal to
        /// this tolerance, then the two values are considered to be almost equal.
        /// </param>
        /// <returns>
        /// true if the first value is less than or almost equal to the second value, false if not.
        /// </returns>
        /// <exception cref="ArgumentException">value1 or value2 is double.NaN</exception>
        /// <exception cref="ArgumentOutOfRangeException">tolerance is not &gt;= 0</exception>
        public static bool IsLessThanOrAlmostEqualTo(this double value1, double value2, double tolerance = 1e-8)
        {
            double.IsNaN(value1).Requires().IsFalse("value1 is NaN");
            double.IsNaN(value2).Requires().IsFalse("value2 is NaN");
            tolerance.Requires(nameof(tolerance)).IsGreaterOrEqual(0);

            var result = (value1 < value2) || value1.IsAlmostEqualTo(value2, tolerance);
            return result;
        }

        /// <summary>
        /// Determines if one value is less than or almost equal to a second value (given some level of tolerance).
        /// </summary>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The the second value.</param>
        /// <param name="tolerance">
        /// The tolerance for differences between the specified values.  If the
        /// absolute value of the difference between the two values is less than or equal to
        /// this tolerance, then the two values are considered to be almost equal.
        /// </param>
        /// <returns>
        /// true if the first value is less than or almost equal to the second value, false if not.
        /// </returns>
        /// <exception cref="ArgumentException">value1 or value2 is double.NaN</exception>
        /// <exception cref="ArgumentOutOfRangeException">tolerance is not &gt;= 0</exception>
        public static bool IsLessThanOrAlmostEqualTo(this decimal value1, decimal value2, decimal tolerance = 1e-8m)
        {
            tolerance.Requires(nameof(tolerance)).IsGreaterOrEqual(0);

            var result = (value1 < value2) || value1.IsAlmostEqualTo(value2, tolerance);
            return result;
        }

        /// <summary>
        /// Calculates the covariance of two sets of doubles.
        /// </summary>
        /// <param name="values1">The first set of doubles.</param>
        /// <param name="values2">The second set of doubles.</param>
        /// <returns>
        /// Returns the covariance of two sets of doubles.
        /// </returns>
        /// <exception cref="ArgumentNullException">values1 or values2 is null.</exception>
        /// <exception cref="ArgumentException">values1 or values2 is empty.</exception>
        /// <exception cref="ArgumentException">Length of sources (values1, values2) is different.</exception>
        public static double Covariance(IList<double> values1, IList<double> values2)
        {
            // check parameters
            values1.Requires(nameof(values1)).IsNotEmpty();
            values2.Requires(nameof(values2)).IsNotEmpty();

            int valuesCount = values1.Count;
            if (valuesCount != values2.Count)
            {
                throw new ArgumentException("Length of sources is different.");
            }

            // covariance of one item is always 0
            if (valuesCount == 1)
            {
                return 0;
            }

            // do the math
            double avg1 = values1.Average();
            double avg2 = values2.Average();
            double cov = 0;
            for (int i = 0; i < valuesCount; i++)
            {
                cov += (values1[i] - avg1) * (values2[i] - avg2);
            }

            cov /= valuesCount;
            return cov;
        }

        /// <summary>
        /// Calculates the covariance of two sets of decimal.
        /// </summary>
        /// <param name="values1">The first set of decimals.</param>
        /// <param name="values2">The second set of decimals.</param>
        /// <returns>
        /// Returns the covariance of two sets of decimals.
        /// </returns>
        /// <exception cref="ArgumentNullException">values1 or values2 is null.</exception>
        /// <exception cref="ArgumentException">values1 or values2 is empty.</exception>
        /// <exception cref="ArgumentException">Length of sources (values1, values2) is different.</exception>
        public static decimal Covariance(IList<decimal> values1, IList<decimal> values2)
        {
            // check parameters
            values1.Requires(nameof(values1)).IsNotEmpty();
            values2.Requires(nameof(values2)).IsNotEmpty();

            int valuesCount = values1.Count;
            if (valuesCount != values2.Count)
            {
                throw new ArgumentException("Length of sources is different.");
            }

            // covariance of one item is always 0
            if (valuesCount == 1)
            {
                return 0;
            }

            // do the math
            decimal avg1 = values1.Average();
            decimal avg2 = values2.Average();
            decimal cov = 0;
            for (int i = 0; i < valuesCount; i++)
            {
                cov += (values1[i] - avg1) * (values2[i] - avg2);
            }

            cov /= valuesCount;
            return cov;
        }

        /// <summary>
        /// Determines the factors of a number.
        /// </summary>
        /// <param name="toFactor">The number whose factors are to be returned</param>
        /// <returns>
        /// Returns the factors of a number.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">x must be &gt; 0</exception>
        public static IEnumerable<int> Factors(int toFactor)
        {
            toFactor.Requires(nameof(toFactor)).IsGreaterThan(0);

            int max = toFactor / 2;
            for (int i = 1; i <= max; i++)
            {
                // ReSharper disable ArrangeRedundantParentheses

                if ((toFactor % i) == 0)
                {
                    yield return i;
                }

                // ReSharper restore ArrangeRedundantParentheses
            }

            yield return toFactor;
        }

        /// <summary>
        /// Calculates the standard deviation of a set of doubles.
        /// </summary>
        /// <param name="values">The double values to use in the calculation.</param>
        /// <returns>
        /// Returns the standard deviation of the set.
        /// </returns>
        /// <exception cref="ArgumentNullException">values is null.</exception>
        /// <exception cref="ArgumentException">values has 1 or fewer items.</exception>
        /// <exception cref="ArgumentException">There is only one value in values.  Two or more required.</exception>
        public static double StandardDeviation(IEnumerable<double> values)
        {
            // check parameters
            // ReSharper disable PossibleMultipleEnumeration
            values.Requires(nameof(values)).IsLongerThan(1);
            var valuesList = values as IList<double> ?? values.ToArray();
            // ReSharper restore PossibleMultipleEnumeration

            // do the math
            double avg = valuesList.Average();
            double sumOfSqrs = valuesList.Sum(value => Math.Pow(value - avg, 2));
            return Math.Sqrt(sumOfSqrs / Convert.ToDouble(valuesList.Count - 1));
        }

        /// <summary>
        /// Returns the standard deviation of a set of decimals.
        /// </summary>
        /// <param name="values">The decimal values to use in the calculation.</param>
        /// <returns>
        /// Returns the standard deviation of the set.
        /// </returns>
        /// <exception cref="ArgumentNullException">values is null.</exception>
        /// <exception cref="ArgumentException">values is empty.</exception>
        /// <exception cref="ArgumentException">There is only one value in values.  Two or more required.</exception>
        public static decimal StandardDeviation(IEnumerable<decimal> values)
        {
            // ReSharper disable PossibleMultipleEnumeration
            values.Requires(nameof(values)).IsNotEmpty();
            return Convert.ToDecimal(StandardDeviation(values.Select(Convert.ToDouble)));
            // ReSharper restore PossibleMultipleEnumeration
        }

        /// <summary>
        /// Truncates everything after the decimal point of a decimal and returns the resulting integer number.
        /// </summary>
        /// <param name="value">The decimal to truncate into an integer.</param>
        /// <returns>Integer with the truncated double.</returns>
        /// <remarks>1.49 will return 1, 1.51 will return 1, 1.99 will return 1</remarks>
        /// <exception cref="OverflowException">value overflows the bounds of an <see cref="int"/>.</exception>
        public static int Truncate(decimal value)
        {
            if ((value > int.MaxValue) || (value < int.MinValue))
            {
                throw new OverflowException("decimal value overflows the bounds of an Int32");
            }

            // if we get here then we don't need to check whether value-.5 will overflow a double's max/min values
            return Convert.ToInt32(Math.Truncate(value));
        }

        /// <summary>
        /// Truncates everything after the decimal point of a double and returns the resulting integer number.
        /// </summary>
        /// <param name="value">The double to truncate.</param>
        /// <returns>Integer with the truncated double.</returns>
        /// <remarks>1.49 will return 1, 1.51 will return 1, 1.99 will return 1</remarks>
        /// <exception cref="OverflowException">value overflows the bounds of an <see cref="int"/>.</exception>
        public static int Truncate(double value)
        {
            if ((value > int.MaxValue) || (value < int.MinValue))
            {
                throw new OverflowException("double value overflows the bounds of an Int32");
            }

            // if we get here then we don't need to check whether value-.5 will overflow a double's max/min values
            return Convert.ToInt32(Math.Truncate(value));
        }

        /// <summary>
        /// Truncates a decimal to a given number of digits.
        /// </summary>
        /// <param name="value">The value to truncate.</param>
        /// <param name="digits">The number of digits to keep.</param>
        /// <returns>
        /// Returns the truncated decimal.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">digits must be >=0</exception>
        /// <exception cref="OverflowException">digits is too high.</exception>
        public static decimal TruncateSignificantDigits(decimal value, int digits)
        {
            digits.Requires(nameof(digits)).IsGreaterOrEqual(0);

            if (digits == 0)
            {
                return decimal.Truncate(value);
            }

            return decimal.Truncate(value * (decimal)Math.Pow(10, digits)) / (decimal)Math.Pow(10, digits);
        }

        /// <summary>
        /// Calculates the variance of a set of doubles.
        /// </summary>
        /// <param name="values">The values used in the calculation.</param>
        /// <returns>
        /// Returns the variance of the set of doubles.
        /// </returns>
        /// <exception cref="ArgumentNullException">values is null.</exception>
        /// <exception cref="ArgumentException">values is empty.</exception>
        /// <exception cref="ArgumentException">There is only one value in values.  Two or more required.</exception>
        public static double Variance(IEnumerable<double> values)
        {
            // check parameters
            // ReSharper disable PossibleMultipleEnumeration
            values.Requires(nameof(values)).IsNotEmpty();
            var valuesList = values as IList<double> ?? values.ToArray();
            // ReSharper restore PossibleMultipleEnumeration

            if (valuesList.Count == 1)
            {
                throw new ArgumentException("Two values are required");
            }

            // Get average
            double avg = valuesList.Average();
            double sum = valuesList.Sum(value => Math.Pow(value - avg, 2));
            return sum / valuesList.Count;
        }

        /// <summary>
        /// Returns the variance of a set of decimals.
        /// </summary>
        /// <param name="values">The values used in the calculation.</param>
        /// <returns>
        /// Returns the variance of the set of decimals.
        /// </returns>
        /// <exception cref="ArgumentNullException">values is null.</exception>
        /// <exception cref="ArgumentException">values is empty.</exception>
        /// <exception cref="ArgumentException">There is only one value in values.  Two or more required.</exception>
        public static decimal Variance(IEnumerable<decimal> values)
        {
            // ReSharper disable PossibleMultipleEnumeration
            values.Requires(nameof(values)).IsNotEmpty();
            return Convert.ToDecimal(Variance(values.Select(Convert.ToDouble)));
            // ReSharper restore PossibleMultipleEnumeration
        }
    }
}
